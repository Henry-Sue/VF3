[TOC]



实现VF3算法需要先了解以下知识：

1. 图的基本概念：节点、边、邻居等；

2. 图同构的定义和判定方法；

3. Python基础语法和面向对象编程知识；

4. 熟悉Python下的Graph数据结构和相关操作，可以使用networkx库实现；

5. 熟悉基本的回溯算法思想。

# 图论

图论主要研究图及其性质、搜索算法、最短路径算法等

## 定义

### 基本概念

图由节点（点）和边（线）组成。

- 节点（vertices）通常也称为顶点或点，用v表示，节点的集合用V表示
- 边（edges）通常也称为弧或线段，用e表示，E表示所有边的集合
- 图（graph）是节点集和边集的二元组
- 如果边是单项的，则图称为有向图（directed）
- 如果边是双向（无向）的，则图称为无向图（undirected）
-  一个简单图是一个没有重复的边和没有自环的图。自环是指一个节点与自己相连的边。 在图中，一条边可以有权重，也可以没有权重。
- 如果边没有权重或所有权重都为一，则称为无权图（unweighted）。
- 如果边有权重且各不相同，则称为有权图（weighted）（由具体应用判断权重为0还是正无穷）
-  图的表示方法有很多种，可以用邻接矩阵、邻接表、关联矩阵等来表示。

图是一种用点和线连接起来的结构，它由顶点集合和边集合组成。顶点表示不同的对象，边表示不同对象之间的关系。

图可以分为有向图和无向图两种。有向图中的边有方向，而无向图中的边则没有方向。此外，带权图还可以表示边具有权重的情况。

> vertex 的复数形式是 vertices

### 数据结构

**无向无权图（undirected unweighted graph）**

边无向，权重相等均为1

- 邻接表（Adjacency List）用于表示图。其中每个顶点（vertex）都被存储为一个键（key）在字典（dictionary）或哈希表（hash table）中，相应的值（value）是一个邻居列表（neighbor list），包含了所有直接连接到该顶点的顶点。(邻接表表示法适用于稀疏图)

>  若某个 vertex 没有边，则 neighbor 中 empty

- 邻接矩阵（Adjacency Matrix）也用来表示图。作为二维数组，每个元素 A\[i][j]表示顶点 i 和 j 之间的边的权值。如果两个顶点之间存在一条边，则对应元素的值为 1，否则为 0，若没有边，则为0或正无穷（由具体应用判断权重为0还是正无穷）。(邻接矩阵表示法适用于稠密图)

> 无向图的邻接矩阵都是对称的（一条边对应两个对称方向）
>
> 有向图的邻接矩阵通常不对称

**有向无权图（directed unweighted graph）**

边有向，权重相等均为1

- 邻接表和邻接矩阵为表示边的有向性，表头应为 from 和 to

**无向有权图（undirected weighted graph）**和**有向有权图（directed weighted graph）**

- 两节点之间无边，对应元素为0/∞，否则为相应权重



## 最短路问题

### 基本概念

- 路径可表示为节点序列`(路径经过的所有节点)`或边序列`(路径上所有的边)`

- 对于无权图，路径的长度 = 路径上边数；有权图需要考虑边的权重相加
- 简单路径：不包含重复顶点的路径（不绕圈）
- 环：起点和终点相同的路径
-  连通图：任意两个顶点之间都有路径
- 强连通图：有向图中，任意两个顶点之间都有路径
- 子图：在一个图中选取一部分顶点和它们之间的边所组成的图
- 度：一个节点的度是指与该节点相连的边的数量

> 若两节点间无路径，则长度为无穷

最短路问题即为图中两个顶点之间的最短路径，分为单源最短路径（single-source）和多源最短路径（）

- SSP：需要已知的图和起点s（source），找到该起点到所有节点的最短路

绘表：

| vertex | dist（从s到vertex的最短路长） | path（在最短路上的前一个节点） |
| :----: | :---------------------------: | :----------------------------: |
|   v1   |               4               |               v3               |
|   v2   |               6               |               v1               |
|   v3   |               0               |               0                |

### SSP in UG（无权）





单源最短路径

单源最短路径问题指的是从图中的一个起点出发，到达图中所有其他顶点的最短路径。通常来说，单源最短路径问题可以使用 Dijkstra 算法或 Bellman-Ford 算法来解决。

\1. Dijkstra 算法

Dijkstra 算法是解决单源最短路径问题的一种经典算法。该算法的基本思想是通过不断地选择当前距离起点最近的未标记顶点来逐步扩展最短路径。Dijkstra 算法可以用于有向无环图（DAG）和非负权图，其时间复杂度为 O(V^2)，其中 V 是顶点数。

Dijkstra 算法的具体实现步骤如下：

\1. 初始化所有顶点的距离为无穷大，起点距离为 0。

\2. 将所有顶点放入未标记顶点集合中。

\3. 选择距离起点最近的未标记顶点，将其标记为已访问。

\4. 对于该顶点的所有出边，更新到达其邻居顶点的距离。如果新的距离比旧的距离更短，则更新该顶点的距离值。

\5. 重复步骤 3 和步骤 4，直到所有顶点都被标记为已访问或者无法到达目标顶点。

\2. Bellman-Ford 算法

Bellman-Ford 算法也是解决单源最短路径问题的一种经典算法。与 Dijkstra 算法不同，Bellman-Ford 算法可以解决带负权边的图中的最短路问题。该算法的基本思想是通过进行 V-1 轮松弛操作来逐步扩展最短路径。Bellman-Ford 算法的时间复杂度为 O(VE)，其中 V 是顶点数，E 是边数。

Bellman-Ford 算法的具体实现步骤如下：

\1. 初始化所有顶点的距离为无穷大，并将起点的距离设为 0。

\2. 对于图中的所有边，进行 V-1 轮松弛操作。每一轮松弛操作都会尝试通过中间顶点缩短到达另一个顶点的距离。

\3. 如果经过 V-1 轮松弛操作后，还存在顶点的距离可以被更新，则说明图中存在负环路，无法得到正确的最短路径。

\4. 如果不存在负环路，则对于每个顶点，其距离即为到达该顶点的最短路径长度。

多源最短路径

多源最短路径问题指的是在一个图中，找到任意两个顶点之间的最短路径。通常来说，多源最短路径问题可以使用 Floyd-Warshall 算法来解决。

\1. Floyd-Warshall 算法

Floyd-Warshall 算法是解决多源最短路径问题的一种经典算法。该算法的基本思想是通过动态规划的方式，逐步计算出任意两个顶点之间的最短路径。

Floyd-Warshall 算法的具体实现步骤如下：

\1. 初始化一个二维数组，其中 A[i][j] 表示从顶点 i 到顶点 j 的最短路径长度。如果顶点 i 和顶点 j 之间没有边相连，则 A[i][j] 的值为无穷大。

\2. 对于每个顶点 k，遍历二维数组，更新顶点 i 和顶点 j 之间的最短路径长度 A[i][j]，即：

  A[i][j] = min(A[i][j], A[i][k] + A[k][j])

\3. 重复步骤 2，直到所有顶点之间的最短路径长度都被计算出来。

Floyd-Warshall 算法的时间复杂度为 O(V^3)，其中 V 是顶点数。虽然其时间复杂度较高，但是在进行多次查询的情况下，该算法的效率比较高。







3. 应用

图论被广泛地应用于计算机科学、物理学、社会学、生物学以及其他领域。以下是图论在计算机科学中的一些应用：

(1) 网络路由：路由算法可用于在计算机网络中找到两个节点之间的最短路径。

(2) 社交网络：社交网络中的节点和边可以被视为一个无向图，可以利用图论算法来推荐好友或发现社交网络中的社群。

(3) 数据库优化：图可以用于优化数据库中两个表之间的关系，以便于查询数据。

(4) 人工智能：图可用于构建推荐系统、决策树等人工智能应用。

(5) 分布式计算：图算法被广泛地应用于分布式计算中，如PageRank算法就是一个经典的基于图的算法。

以上就是图论的定义、基本概念和应用等方面的详细讲解。

